由于已经熟悉 V8 引擎的工作原理、事件循环（Event Loop）以及 TypeScript 的结构化类型系统，我们将跳过编程基础，直接切入 Rust 的语言核心设计。我们将结合[The Rust Programming Language](https://doc.rust-lang.org/book/title-page.html) 教程，完成从“运行时解释”到“编译时约束”的思维迁移。

## 1. 核心范式转移：世界观的重构

在 TypeScript 中，你的世界由 **GC（垃圾回收器）** 守护。我们创建对象，传递引用，V8 在后台默默计算引用计数或标记清除。我们仅关注“业务逻辑”，而非“内存生命周期”。

Rust 的世界没有 GC。但它也不是 C++ 那种需要手动释放。Rust 引入了第三种模式：**所有权（Ownership）与借用（Borrowing）**。

可以将 Rust 编译器（基于 LLVM）看作是一个**极端严格的、不可配置的 ESLint**，它在编译阶段就强制执行内存安全规则。如果代码能编译通过，它通常就是内存安全的。

## 2. 内存模型：解构“变量”的本质

在 TS 中，`const a = { val: 1 };`，变量 `a` 只是堆内存中那个对象的引用（指针）。

在 Rust 中，类型分为两类：**实现了 `Copy` trait 的（栈上数据）** 和 **未实现 `Copy` trait 的（拥有堆资源的）**。

### 2.1 绑定与所有权 (Binding & Ownership)

Rust 的核心规则：**任意时刻，一个值只能有一个所有者。** 但这针对的是**所有权转移 (Move)** 的情况。对于基础类型，Rust 的行为和 TS 的 Primitive 类型是一样的。

#### 情况 A：栈上数据（基础类型）—— 复制 (Copy)

对于编译期已知大小的简单类型（整数、浮点、布尔、字符、以及仅包含这些类型的元组/数组），Rust 会自动进行 **Copy**。这和 TS 的 `number` 行为一致。

- **TypeScript (值拷贝):**

```typescript
let x = 5;
let y = x; // y 是 x 的副本
// x 依然有效且独立
```

- **Rust (自动 Copy):**

```rust
let x = 5;
let y = x;
// ✅ 发生 Copy！
// 因为 i32 实现了 Copy Trait。
// 它们完全在栈上，复制极其快速，不需要所有权转移机制来保护堆内存。

println!("x = {}, y = {}", x, y); // 编译通过，x 依然有效

```

#### 情况 B：堆上数据（复杂类型）—— 移动 (Move)

这是 Rust 与 TS 最大的不同点。对于 `String`, `Vec` 等拥有堆内存的类型：

- **TypeScript (引用共享):**

```typescript
let a = { name: "TS" };
let b = a;
// a 和 b 指向同一个堆内存地址。
// 修改 b.name 也会影响 a。V8 GC 负责何时回收。
```

- **Rust (所有权转移):**

```rust
let a = String::from("Rust");
let b = a;
// ⚠️ 发生 Move！
// 1. 栈上的指针 (ptr, len, cap) 被复制给了 b。
// 2. 堆上的数据没有复制（没有深拷贝）。
// 3. 编译器强制宣告：a 失效了。

// println!("{}", a); // 编译错误：use of moved value: `a`

```

**深度解析 (Move)**：为什么 `a` 必须失去所有权？因为如果 `a` 和 `b` 同时有效，当它们离开作用域时，Rust 会分别调用 `drop()`。这会导致对同一块堆内存释放两次 (**Double Free**)，这是极度危险的内存错误。

**给 Senior TS 开发者的总结：**

- **Copy 语义**：类似于 TS 的 Primitive Types (`number`, `boolean`)。在 Rust 中对应 `i32`, `bool`, `f64`, `char` 等。另外包含这些基础类型的元组和数组，也实现了Copy语义，其数据分配在栈上。
- **Move 语义**：类似于 TS 的 Object Types (`Object`, `Array`)，但 Rust **禁止** 两个变量同时持有同一个对象的“写权限”或“释放权”，所以把旧变量作废了。

### 2.2 栈与堆的精确控制 (Precise Stack & Heap Control)

在 TypeScript (V8) 中，数组是一个黑盒。它可能是 `Packed Smi` (紧凑小整数)，也可能是 `Holey Elements` (稀疏数组)，V8 会根据你的操作动态调整底层存储模式。

Rust 强迫你在**定义数据结构**时就决定内存布局，以此换取确定性的性能。

| 概念                  | TypeScript                           | Rust 对应物     | 内存位置 (默认)  | 深度特性解析                                                                                      |
| --------------------- | ------------------------------------ | --------------- | ---------------- | ------------------------------------------------------------------------------------------------- |
| **元组 (Tuple)**      | `[number, string]`                   | `(i32, String)` | **Stack** (混合) | 只是将字段紧挨着放在栈上。 注意：如果元组包含 String，String 的元数据在栈上，实际文本还在堆上。\* |
| **数组 (Array)**      | `FixedLengthArray` (TS 类型体操模拟) | `[i32; 5]`      | **Stack**        | **编译期定长**。内存中仅仅是连续的 5 个整数，没有任何头部开销 (Overhead)。**无法 push/pop**。     |
| **动态数组 (Vector)** | `Array<T>`                           | `Vec<T>`        | **Heap** (数据)  | **动态扩容**。栈上存“胖指针”，堆上存数据。                                                        |

#### 深度解析：内存视角的差异

作为 TS 开发者，你需要建立以下心智模型：

1. **Array `[T; N]` 是“内联”的**：
   如果你有一个结构体 `struct Point { coords: [f32; 3] }`，这 3 个浮点数是直接嵌入在结构体内存里的。没有指针跳转，没有缓存未命中 (Cache Miss)。这在做矩阵运算或高性能图形学时是巨大的优势。
2. **Vector `Vec<T>` 是“胖指针” (Fat Pointer)**：
   `Vec<T>` 在栈上不仅仅是一个指针，它是一个包含三个字段的 Struct（通常占用 24 字节，在 64 位机器上）：

- `ptr`: 指向堆内存起始地址的指针。
- `len`: 当前已使用的长度。
- `capacity`: 当前堆内存分配的总容量。

**V8 对比**：当你对 TS 数组 `push` 时，V8 可能会偷偷把底层存储从 C++ 数组切换成 Hash Map（如果数组变得稀疏）。Rust 的 `Vec` 永远保证是连续内存，如果 `capacity` 不够，它会申请一块更大的新内存，把数据 `memcopy` 过去，然后更新栈上的 `ptr`。

**关键决策点：**

- **用 `[T; N]**`：当你处理固定大小的缓冲区（Buffer）、数学向量（Vector3）、或者确定的哈希摘要（SHA-256 result）时。
- **用 `Vec<T>**`：当你处理用户输入、文件内容、或者任何运行时才能确定大小的数据集合时。

## 3. 变量与可变性：默认不可变

### 3.1 深度不可变性 (Deep Immutability)

- **TS:** `const` 只是锁引用。`const obj = {}; obj.x = 1` 是合法的。
- **Rust:** `let` 默认锁定一切。

```rust
let x = 5;
x = 6; // 编译错误，默认不可变

let mut y = 5; // 必须显式声明可变
y = 6; // 编译通过

```

**编译器视角：** 如果没有 `mut`，LLVM 可以在编译期进行极其激进的常量折叠和寄存器优化，因为它可以确信这块内存不会被修改。

### 3.2 Shadowing（变量遮蔽）

TS 开发者可能会觉得重名变量很奇怪。但 Rust 鼓励这样做，主要用于**类型转换**链。

```rust
let spaces = "   ";           // 类型: &str
let spaces = spaces.len();    // 类型: usize (遮盖了上面的变量)

```

这在底层实际上是在栈帧（Stack Frame）上分配了两个不同的槽位。对于编译器来说，这就是两个完全不同的变量，只是刚好名字一样。这避免了 `spaces_str`, `spaces_num` 这种命名污染。

从 TypeScript 到 Rust，最大的挑战不是语法（那很容易），而是**心智模型**：

1. **时刻思考内存**：这个变量是在栈上还是堆上？谁拥有它？
2. **拥抱编译器**：TS 编译器是你的顾问，Rust 编译器是你的看守。不要试图绕过它，要理解它为什么报错。通常它报错，是因为你的代码真的存在内存安全隐患。
3. **从宏观入手**：利用你对 V8 的理解，去思考 Rust 如何在没有 GC 的情况下通过 资源获取即初始化 实现同样的自动化内存管理。

**建议学习路径：**
从 [The Rust Programming Language](https://doc.rust-lang.org/book/title-page.html) 开始，但每遇到一个新概念，都停下来画一张“内存布局图”。一旦你理解了 Stack 和 Heap 上的指针流向，Rust 就变得清晰无比。
