对于 JS/TS 开发者来说，这两者通常是隔离的：`if` 是用来控制跳转的“语句”，`1+1` 是用来计算的“表达式”。Rust 继承了函数式语言（Haskell, Scala等语言）血统：**控制流即数据流**。除了 `let` 和 `fn` 声明外，几乎所有代码块本质上都是表达式，都有返回值。

# Rust 核心范式：

基于表达式的控制流 (Expression-Oriented Control Flow)。在 Rust 中，控制流不仅仅是代码执行的“方向盘”，它同时也是产生数据的“生产线”。

这意味着你几乎可以把任何逻辑块（`if`, `match`, 代码块 `{}`）直接赋值给变量或作为函数返回值。这消除了“先声明变量，再在不同分支里赋值”的中间状态，从而增强了不可变性（Immutability）。

## 1. 根本对立：语句 (Statement) vs 表达式 (Expression)

要理解为什么把它们放在一起，必须先看清它们的区别。

### 1.1 传统视角 (JS/TS)

在 TypeScript 中，控制流主要是**语句**。语句执行动作，但没有产出。

```typescript
// TS 风格
let result; // 1. 必须先声明一个可变变量 (副作用的温床)
if (condition) {
  result = 10; // 2. 在分支中修改它
} else {
  result = 20;
}
// result 的类型可能隐含 undefined，或者需要复杂的类型推断
```

### 1.2 Rust 视角 (表达式优先)

在 Rust 中，控制流结构（`if`, `match`, `loop`）本身就是**表达式**。它们会“求值”并“返回”结果。

```rust
// Rust 风格
// 1. 直接通过 if 表达式计算出结果，绑定给不可变变量 result
let result = if condition {
    10
} else {
    20
};
// result 从出生那一刻起就是确定的，且不可变。

```

**连接点：** 之所以把“表达式”和“控制流”放在一起讲，是因为在 Rust 中，**控制流结构就是生成值的表达式**。它们是一体的。

## 2. 深度解构：常见控制流的“表达式化”

让我们一个个看 Rust 是如何把传统的控制流变成数据管道的。

### 2.1 `if` 是三元运算符的完全体

Rust 没有 `condition ? true : false` 三元运算符。因为 `if` 已经足够强大。

- **TS**: `if` 是语句，不返回值。
- **Rust**: `if` 是表达式，返回最后一个式子的值。

```rust
let status = if score > 60 { "Pass" } else { "Fail" };

```

**约束**：因为它是表达式，所以 `if` 和 `else` 分支返回的数据类型**必须一致**。你不能一个分支返回 `i32`，另一个返回 `String`（除非用 Enum 包裹）。

### 2.2 `match` 是基于模式的超强表达式

这是 Rust 逻辑流的核心。它不仅仅是流程分支，更是**数据提取器**和**转换器**。

```rust
let input = Option::Some(100);

// match 表达式直接求值
let number = match input {
    Some(n) => n * 2, // 提取 n，计算 n*2，并作为返回值
    None => 0,
};
// number 自动被推导为 i32

```

### 2.3 `loop` 也可以返回值

TS 的 `while/for` 只是循环。Rust 的 `loop`（无限循环）可以像函数一样返回值。这在重试逻辑中非常有用。

```rust
let mut counter = 0;

// 这个 loop 表达式最终会产出一个 i32
let result = loop {
    counter += 1;
    if counter == 10 {
        break counter * 2; // ✅ break 携带值跳出，类似于 return
    }
};

assert_eq!(result, 20);

```

### 2.4 代码块 `{}` 也是表达式

这是很多新手忽略的点。一对花括号 `{ ... }` 本身就是一个表达式，它的值取决于**最后一行**。

```rust
let y = {
    let x = 3;
    x + 1 // 没有分号 -> 返回 4
};

println!("y is {}", y); // y is 4

```

**应用场景**：这允许你在一个大的函数内部创建一个小的、隔离的变量作用域，计算出一个值，而不污染外部作用域。

## 3. 核心机制：分号 (`;`) 的魔法

在 Rust 中，分号不仅仅是行尾结束符，它是一个**运算符**。

- **无分号** = **Return Value (表达式)**：把值向外抛。
- **有分号** = **Suppress Value (语句)**：执行计算，但把值丢弃，返回单元类型 `()` (Unit)。

## 4. 为什么这么设计？(The "Why" for Senior Devs)

作为资深全栈，你可能会问：为什么要改变我习惯的 `return` 写法？

1. **函数式编程的血统**：Rust 深受 OCaml/Haskell 影响。在这些语言中，一切皆计算，一切皆返回。
2. **减少中间状态 (Immutability)**：

- **TS 做法**：`let x; if (a) x=1; else x=2;` -> `x` 必须是可变的 (`let`)，且在初始化前存在一段“未定义”的真空期。
- **Rust 做法**：`let x = if a {1} else {2};` -> `x` 可以是不可变的，且它是**原子性初始化**的。这消除了大量的状态同步 bug。

3. **类型系统的完整性**：编译器可以更容易地检查分支逻辑的类型一致性。

## 5. 总结

把你对“控制流”和“表达式”的理解合并起来：

- 在 TS 中，你写代码是：**做动作 A，然后做动作 B，最后 return 结果。**
- 在 Rust 中，你写代码是：**构建一个巨大的算式，这个算式由 if、match 和代码块组成，最终求出一个结果。**
